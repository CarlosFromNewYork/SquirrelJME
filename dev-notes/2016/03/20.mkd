# 2016/03/20

## 00:12

Refactor is going well, things are much nicer now.

## 00:20

First day of spring also.

## 15:21

This refactored code is much simpler now and likely much faster too.

## 15:57

I believe I have a short or too long of a read somewhere.

## 16:04

Based on the dump and the values I am seeing, I am short two bytes.

## 16:07

And looking at the hex dump of the class, those missing two bytes are for
the ignored attribute, since the length is an integer and not an unsigned
short.

## 16:15

Method handles will require slightly more complex work to make them
cachable because identifiers can contain `(` and `)`. They are also not in
fixed positions. So I suppose what I will do then is have a fixed offset and
length similar to the binary name, then substring as required.

## 18:49

`sloccount` gives me `java: 13646 (100.00%)`. Also, the parsing of the block
of code will be inline so no byte arrays have to be filled by the attribute
and then parsed that way. Thus, the class parsing code will remain light and
not require too heavy allocations beyond the normal allocations. During my
pass, I can also use what is used by the method and ignore stuff that is not
used. Since the constant pool is shared with everything, some stuff might not
be needed at all for specific methods.

## 19:01

The good thing is that the subroutine byte codes are completely unsupported,
which means that parsing classes is simpler and I less likely have to worry
about recursive states where a byte code can have a few thousand different
states.

## 19:05

Looks like `StackMap` is a bit less compact version of the `StackMapTable`.
That is, the information appears to be similar so far, except that it is
simpler to parse. Basically think of if everything in the `StackMapTable`
were entire frames. I see the very familiar `verification_type_info`. And
reading the specification, the type information is exactly the same. So when
writing the checker, I can combine and check for both states accordingly. This
means that `StackMap` and `StackMapTable` will be folded into entire full
states which are then checked on input instructions.

## 21:34

Thinking about it, the `StackMapTable` might not even be needed. I could
technically skip it if I force the requirements as if `StackMapTable` were
there. The way Java byte code runs on moderm VMs is that each address in the
byte code operations must have only a single valid state. The Java compiler
enforces this. However, I would have to check if older J2ME classes also share
this property. Ignoring the stack map table would simplify things greatly
because I would not need to parse it at all. So there would quite literally
only be two attributes. However, if a `StackMapTable` is illegal then the
normal VM would fail. However, the table does help in cases where exceptions
are handled to know if local variables and such are filled or not. As for
the byte code, I am going to transform it to a kind of register based format
which will be used by the interpreter and in the future the native recompiler.
Ignoring the table would be faster and would produce code faster. It is kind
of redundent, although skipping it would violate the specification.

