# 2016/03/26

## 02:06

For stack entries, I need to actually hide when the stack grows a bit too
small, since currently they are treated like locals.

## 16:12

Was mowing about 2 acres of grass. Anyway, I have an idea for semi-whole
program optimization when it comes to fields. When I load a class I need to
have it so that partially loaded classes can be read. Then if global
field optimization is enabled, I look in the partially loaded set of classes
to see if one matches the field the class is in. If it is found, then the
flags and potential constant value of the class determine if the value is
treated as constant or not. By default if it is not enabled then fields in
other classes would be treated as always volatile, while fields in the current
class are treated with their respective flags and values. I have to watch when
loading classes though, that I do not fail if the dependent class is malformed.
I would have to catch the `JVMClassFormat` error and then just default to the
`volatile` state. Also, to prevent failing classes from loading again I can
put in a list of failed classes which are not in the classpath at all. That
way they are never retried over and over again.

## 19:02

One thing though is that there has to be checking whether the operations
flow correctly when they go from one set to another. I could actually be
smart about it and put the code in the program state atoms and such. Doing it
that way would also mean I can easily handle the metadata also without having
the metadata handling code everywhere. So I would essentially perform a virtual
not yet done push to the stack of the current atom to affect the next atom.
If the next atom has state set for it and has variables then it is made sure
that the given state would still be valid. So essentially, do a virtual pop of
of the stack (does not actually change the state), then perform the operation
of it where the result is stored in the target atom. If the target atom has
state then it must match (except for the operator links). This I suppose would
be the cleanest way to handle the operator links, since having that code in
all of the byte code handlers would be very messy and error prone.

## 19:10

Actually looking at my code, the previous slot for the previous operation
is incorrect.

