# 2016/03/23

## 00:03

For a single pass system with no allocations for temporary byte code that is
read, one problem I will encounter during translation is exceptions. One thing
I do know about exceptions though, is that the stack is wiped away yet the
locals are kept the same. The exception handler can never be the first
operation. On entry of the method, there are just the locals and no stack.
Exception handlers get a single stack element containing the exception which
was thrown. Also, each instruction can only have a single stack state also.
Thus if some byte code starts modifying an object on the stack, then it is
likely an exception handler. The only thing to determine though are future
`goto` operations going to these locations with matching stacks.

## 00:09

So with the first instruction never being an exception is a rule. I would
just flow normally after that and make sure elements are valid and such. There
can also be a heuristic to guess code which is likely an exception handler.
If it is alone for example. If code is reached which is never reachable by
normal flow of execution then it is likely an exception handler. The only
case of it not being so would be if a goto were just tossed to a future
address, which then jumps back to the given point. So for unknown states I
will have to allocate some buffers to store byte code temporarily and defer it
to until the exception handler table is read. If a method is very simple then
this will never occur. Unknown states would only be for code outside the
starting program flow.

## 10:54

Ok, so the goal with byte code parsing is that it needs to be light and simple.
There are many operations and a large number of them are calculated similarly
such as when stack operations are performed. So what I am thinking of is having
the operations stored in a simple text file with their stack opertions and
such. However, alternatively I could just make a gigantic switch statement.
The switch would be more inline so to speak. I could use reflection and cache
the classes, then each byte code operation would be in its own class and such.
I can do this because I can call `Class.forName()` and call `newInstance()`.
However, they would need to be interfaces and I would also need a bridging
object. The opcode handlers would be single instance, however they would also
be a lookup table that can be static so to speak. Doing it that way I do not
have to clutter the class with details, or have gigantic enumerations which
are pre-exist in memory. The only time I need an operation is when I am
handling it.

