# Nutty And Retro Form

__THIS DOCUMENT IS INCOMPLETE AND MAY BE REMOVED IN THE FUTURE.__

This document specified the intermediate language which SquirrelJME uses
internally to represent code during transcompilation. Due to the use of
potentially very memory constrained systems it is designed to be small and
compact, yet potentially wide enough to make parsing slightly easier.

It is not SSA or CPS.

The following are design goals:

 * Compact, it must not use all the memory available to a system if for example
   it only has 48KiB of available RAM. Being compact would for the most part
   add potential for there to be a JIT on such limited systems.
 * Mostly extendable for general programs.
 * Should cover almost all programs for embedded environments which use
   Java ME. Gigantic methods, libraries, and such will generally not fit on
   devices which run Java ME.

# A CISC-ish Architectures

Instructions are variable sized and operate purely using registers (except
for loads and stores).

There are 127 registers. Each register is assigned a fixed type that it may be:

 * int
 * long
 * float
 * double
 * reference

There are two register selection slots: A and B. When slot bits are explicitely
specified then they are changed, otherwise the slot of the previous (linear)
instruction is used.

# Instruction Format

## Specifier

All instructions start with a instruction specifier:

    76543210
    ========
    fOOOOOab

 * **f** -- For operations, this is always zero.
 * **O** -- The operation to perform.
 * **a** -- If set, then a byte follows specifying the A register used.
 * **b** -- If set, then a byte follows specifying the B register used, if the
   A register is not implicit then this follows that byte.

This means that instructions at most take up 3 bytes.

## Explicit register

If the explicit slot for a register is set, then the following form is used.

    76543210
    ========
    tRRRRRRR

 * **t** -- For explicit register sets, this is always one.
 * **R** -- The register to use for data access.

## Constant/Jump specifier

If a constant value needs to be specified or a jump is to be performed then
a variable length byte based encoding is used following the explicit registers.
Similarly to the explicit register, the uppermost bit is always set and the
lowest bits are used for the value. Values start at the lowest and increase in
shift. If there are no more constants to load then the remaining upper bits
are set to the highest specified bit in the constant.

# Operations

There is a very limited set which specifies the operation count. Due to the
certain nature of how values may be treated, some instructions perform
differing actions.

Performing an operation where slots A and B differ in type are illegal except
for specific instructions.

## Register Type Specific

### A and B == `int`, `long`, `float`, or `double`

#### Op _0b00000 (0)_ - ADD

`A = (A + B)`.

#### Op _0b00001 (1)_ - SUBTRACT

`A = (A - B)`.

#### Op _0b00010 (2)_ - MULTIPLY

`A = (A * B)`.

#### Op _0b00011 (3)_ - DIVIDE

`A = (A / B)`.

#### Op _0b00100 (4)_ - REMAINDER

`A = (A % B)`.

#### Op _0b00101 (5)_ - AND

`A = (A & B)`.

#### Op _0b00110 (6)_ - OR

`A = (A \| B)`.

#### Op _0b00111 (7)_ - XOR

`A = (A ^ B)`.

#### Op _0b01000 (8)_ - LOGICAL_SHIFT

`A = (A << B)` (_B_ is positive) or `A = (A >>> B)` (_B_ is negative).

#### Op _0b01001 (9)_ - ARITHMETIC_SHIFT

`A = (A << B)` (_B_ is positive) or `A = (A >> B)` (_B_ is negative).

#### Op _0b01010 (10)_ - NEGATE

`A = -A`.

#### Op _0b01011 (11)_ - UNUSED

#### Op _0b01100 (12)_ - UNUSED

#### Op _0b01101 (13)_ - UNUSED

#### Op _0b01110 (14)_ - UNUSED

#### Op _0b01111 (15)_ - UNUSED

### A and B == reference

#### Op _0b00000 (0)_ - UNUSED

#### Op _0b00001 (1)_ - UNUSED

#### Op _0b00010 (2)_ - UNUSED

#### Op _0b00011 (3)_ - UNUSED

#### Op _0b00100 (4)_ - UNUSED

#### Op _0b00101 (5)_ - UNUSED

#### Op _0b00110 (6)_ - UNUSED

#### Op _0b00111 (7)_ - UNUSED

#### Op _0b01000 (8)_ - UNUSED

#### Op _0b01001 (9)_ - UNUSED

#### Op _0b01010 (10)_ - UNUSED

#### Op _0b01011 (11)_ - UNUSED

#### Op _0b01100 (12)_ - UNUSED

#### Op _0b01101 (13)_ - UNUSED

#### Op _0b01110 (14)_ - UNUSED

#### Op _0b01111 (15)_ - UNUSED

## Generic Operations

### Op _0b10000 (16)_ - SET

`A = B`.

A and B must be compatible value types.

### Op _0b10001 (17)_ - UNUSED

### Op _0b10010 (18)_ - UNUSED

### Op _0b10011 (19)_ - UNUSED

### Op _0b10100 (20)_ - UNUSED

### Op _0b10101 (21)_ - UNUSED

### Op _0b10110 (22)_ - UNUSED

### Op _0b10111 (23)_ - UNUSED

### Op _0b11000 (24)_ - UNUSED

### Op _0b11001 (25)_ - UNUSED

### Op _0b11010 (26)_ - UNUSED

### Op _0b11011 (27)_ - UNUSED

### Op _0b11100 (28)_ - UNUSED

### Op _0b11101 (29)_ - UNUSED

### Op _0b11110 (30)_ - CHANGE_A (Constant/Jump)

`A = Constant`.

If a constant value is not specified (an instruction byte follows) then the
explicit is changed and no slots are changed. Otherwise, the slot specified
by the register is set to the given value.

Both registers may be explicit, however any read constant is placed into A.

### Op _0b11111 (31)_ - CHANGE_B (Constant/Jump)

`B = Constant`.

Similar operation as **CONSTANT A**.

Both registers may be explicit, however any read constant is placed into B.

