# Reddit Updates

This self post is to indicate the current project status and will be modified
accordingly.

If there are any questions, then a self post can be made (in another thread).

_Last Updated: 2016/08/16_

----

__Currently being worked on:__

 * Class library
   * Currently anything required to make the tests run properly
 * ELF Generator
   * Sections (.text, .data, etc.; not actually needed for execution)
 * Java Virtual Machine
 * JIT compiler
   * MIPS
 * Operating System Targets
   * `mips-*+*,*.linux.generic`

----

__Stuff to be done, but not currently being worked on:__

 * Deflate algorithm

----

__What has been done:__

 * Basic distribution structure (2016/07/20)
 * Basic target output (2016/07/20)
 * ELF Generator
   * Everything except sections. (2016/08/16)
 * Class file support (2016/04/03, refactored 2016/04/26)
 * Inflate algorithm (2016/04/08, refactored 2016/08/16)
 * ZIP read support (2016/04/08)
 * ZIP write support (2016/07/20)

===============================================================================

__Update 2016/08/16:__

The previously mentioned C compiler source generation has been completely
removed. The JIT backend has been revamped a bit and I have generation of
ELF files which instantly crash (because the entry address points to data and
no code is generated yet). There have also been a number of speed improvements
mostly in the inflate algorithm (you can read about that here:
<http://multiphasicapps.net/tktview?name=9f0481d03d>) and some other related
classes.

So at this point, I just need to write the native code generator and other
initialization routines to get a virtual machine bootstrapped and executed. I
will likely start with a simple `Hello Squirrels!` type program which would be
written purely in Java. Note that I intend the JIT to be very fast when it
comes to code generation, so that not all optimizations will be accounted for.
For comparison, long running programs will run faster using Oracle's HotSpot
than SquirrelJME. However, very short programs in SquirrelJME will likely be
faster (since SquirrelJME is a fraction of the size of OpenJDK and the main
class library will be ahead of time compiled). With my current generator plans
I would say that the minimum amount of memory required to run a program would
be along the lines of 1MiB. Do note that I do plan the garbage collector to be
stop the world (much easier to write and generally is faster) and as fast as
possible.

I also seem to never have mentioned that the mascot has a name now, and his
name is _Lex_. The mascot was also converted to SVG and you can find that
in: `src/mascot-svg/net/multiphasicapps/squirreljme/mascot/svg/`.

__Update 2016/07/20:__

I currently have a basic build output now. I am currently working on compiling
Java byte code and all of the classes to C which can then be compiled using a
modern C compiler. Targetting C currently will allow me to develop the JIT
compiler and be able to easily test it on a host system. Then once the JIT is
developed enough and there are enough classes implemented in the main library,
I can then work on native machine code generation.

Note that, even though C code could theoretically be used in other projects,
because _SquirrelJME_ is under the **GNU GPLv3** other projects must be
compatible with that license (and in effect will fall under that license). The
output code relies on the main class library in order to function properly.

__Update 2016/07/14:__

Still working on this project, refactoring some parts of the code and making
things more efficient so that the project in the future is not a giant mess.

Also, I have decided to switch to the **GNU GPLv3** from the **GNU AGPLv3**,
this means that there would be less restrictions to the code. I will slowly be
changing the licenses in the files (since having a massive 700 file commit is
a bit ugly).

__Update 2016/05/17:__

I updated my main site to be the repository for this software (rather than a
bland page), so update your bookmarks and URLs.

Currently, I am still working on the Interpreter/Compiler, however compared to
the previous generation it is turning out to be far superior in code quality.

Also, I decided to start work on the kernel which would be the core interface
between the virtual machine and the system. Having the kernel interface in
place would allow me to better meld in the interpreter/compiler in the future.
It also means that the current kernel I am working on (runs on the host JVM)
can be used to test programs as if they were in the SquirrelJME environment
itself. It also feels nice to have an actual interface propping up to feel the
results better than just writing and testing back end code.

So porting to operating systems would require the following:

 * Native compiler (to generate code).
 * Kernel interface (which runs and can load the code).

Also for certain systems, there might not be an operating system and as such
filesystem drivers may be needed, the current project layout should allow for
such drivers to be shared across ports.

__Update 2016/05/07:__

SquirrelJME now has a mascot! He resides in a base64 encoded PNG (because
binary files are a bad idea in version control) at `src/mascot/`.
He has no name currently however.

__Update 2016/04/26:__

Refactored the class file reading code so that it is much nicer and far easier
to integrate into the compiler and interpreter. Although I have previously
refactored this code, this new refactor is far better than before.

The old interpreter is defunct as it was a pure interpreter and was quite slow
in operation, the next generation interpreter being written currently should be
much faster.

__Update 2016/04/08:__

Reading 32-bit ZIPs along with standard inflate decompression works. Note that
the ZIP code needs to be profiled in the future to increase its speed since
appears a bit sluggish. There are some optimizations which can be made in some
backing code to make it a bit faster, however it should be noted that the ZIP
and inflate decompression code are optimized for reduced memory consumption
compared to Java SE which considers speed first.

64-bit ZIPs (ones with entries larger than 2GiB or ZIPs beyong 4GiB) are not
currently supported, however in general for Java ME these ZIPs should rarely
if ever be encountered.

__Update 2016/04/03:__

Performing a refactor of the class file, interpreter, and base program support
so that they are not combined into one. When it is complete, the code will be
much cleaner and nicer than before. It will also be easier to maintain and to
swap out things.

__Update 2016/03/31:__

The interpreter will also act as a compiler so that eventual code generation
will follow the same route, code wise. Instructions will be implemented on an
as-needed basis (when they need to be executed) while the interpreter is still
worked on to support the execution of the basic test programs I have written.

