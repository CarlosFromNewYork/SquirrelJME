# 2016/06/08

## 09:21

For the memory pool manager I can have multiple base addresses. The base
address would be used as a means to determine the address where data is
placed and would be used for pointers in objects for example.

## 09:31

I was thinking of having the memory pool manager handle object allocations
and such, however I believe instead that should be placed in another project.
This way the object in memory management can be shared by the kernel and the
interpreter potentially.

## 09:36

I need a package which can handle comparison and other operations of unsigned
values.

## 10:53

For the memory pool, it should be used by the manager and then associated with
the kernel potentially.

## 11:20

Going to need a common and generic object manager. Monitors and locks can be
managed by atomic read/writes of values. So the memory pool will also need
compare and set/test or similar for the native types.

## 11:43

Hopefully 16 bytes reserved at the start of the memory pool is sufficient to
handle virtualized atomic operations and such (in case there is no native
support for it).

## 12:21

Actually that would be a bad idea. The memory pool should just be a memory
pool which can be read and written to. An object manager can reserve space and
such. This way the memory pools can shared with the simulator and such.

## 12:23

The atomic operations also cannot be in the abstract pool either because the
reserved bytes are gone now.

## 14:46

I can test differently sized pointer values in the interpreter. However one
thing to consider is that this would limit the interpreter's maximum amount
of memory. Each instance of a loaded class for each virtual machine would need
the `Class` object allocated for classes along with their static fields.

