# 2016/06/23

## 03:16

A rather large thunderstorm is closing in.

## 03:59

A _very_ large thunderstorm.

## 04:32

Taking yesterday's idea, I can have a module based Java virtual machine.
Basically the virtual machine is initialized and it searches for modules in
the class path. The modules can provide filesystem access and such for example.
The modules could also provide execution environments also possibly.

## 04:40

The JVM at its base can be abstract, where implementations could implement
native CPU support and such. So for example process creation and memory
management is not handled by the JVM at all but by the implementation.

## 04:43

Then using the filesystem module, class units that use that filesystem
interface can be used.

## 04:46

The JVM would be given main arguments, setup the launcher, and then just
provide an interface for things. So the `JVM` would be similar to the kernel
except that it would be far simpler and more modular.

## 05:06

So `JVM` and family will just be similar to the kernel, then I can move some
of the `PVM` code over it. This way there are somewhat common interfaces used
and duplicated code for native implementations would be completely rewritten
from scratch.

## 05:28

Heard what sounded like a gun shot and the power failed, that would likely be
a transformer.

## 09:28

I believe for the filesystem, regardless of the OS I will use the same
structure. The `@` will be the root specifier, followed by the name of the
root. The directory separator would be `/`. All filesystems that exist on the
host along with virtual ones will exist under this scheme. This would simplify
the very different file system handling across various systems. So for
example on Linux the UNIX root would just `@root/` while on Windows `C:` would
be called `@c/`. The roots would be case insensitive.

## 09:36

Not sure about the modules, but it should work.

## 09:59

Actually for the device I/O, I should use the device I/O interfaces and such.
This way I do not invent my own.

