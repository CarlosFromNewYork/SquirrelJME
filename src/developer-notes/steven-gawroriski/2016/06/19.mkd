# 2016/06/19

## 08:15

I believe I know what is wrong with my merge sort. I am swapping the output
with the lowest sorted value then I skip over it. I must not do that.

## 08:36

The merge sort with the stack that I have is a bit complex, it can really just
be done with a single pivot that splits the left and right sides.

## 08:57

Pivots would be even more complex.

## 09:16

Actually my merge may have not worked due to `&&` and not `||`. The merge
was only performed if both sides had values. This would work if values were
shifted over however.

## 09:20

So right now I have a working double memory merge sort, I can later turn it
into a single memory merge sort at the cost of speed. Potentially if allocating
the second array fails, I can fall back to using insertion to sort it.

## 09:49

I believe for the built-in sorting algorithm that `Arrays` and `Collections`
will use will just be a value based in place merge sort or similar. I can
still have minimal duplicated code by using a special interface.

## 09:54

Technically, the `IndexedSort` could use this `ValueSort` since an interface
method takes care of the comparison. The value sorter will just have a set and
get of a specific index so that it can sort it properly along with a standard
comparison by extending `IndexedComparator`.

## 11:14

Now that I have a sorting algorithm, I can sort the JAR entries.

## 12:32

So with binary searching, I now have the following times:

 * 1.0s
 * 2.0s
 * 1.7s
 * 1.8s
 * 1.0s

So basically no real difference to being up to a second slower. However, the
slight loss in speed will benefit later runs.

