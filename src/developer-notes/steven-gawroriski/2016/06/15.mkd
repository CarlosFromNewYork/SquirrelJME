# 2016/06/15

## 07:48

The configuration would best be immutable for the most part. This way it could
more easily be used when threads and such need to be created.

## 07:50

However, perhaps just an immutable class that can be initialized.

## 07:55

For a mutable variant I can just use a kind of builder.

## 08:22

I need better names for the CPUs in the builder. I will go with the planned
variants.

## 08:39

So when it comes to building, I need a JIT that could cache and provide native
executable code fragments for classes and such.

## 08:43

I believe the simulator with multiple simulations, groups, and otherwise would
be a bit complex. I will just have a single simulation process that runs and
executes until it completes.

## 08:45

So is the JIT on a per class basis or a per method basis? Classes are together
in a group, so it would likely be better optimized to compile classes all at
the same time.

## 09:55

A configuration system for configuring builds would be the best rather than
just a CPU and OS target.

## 10:04

I would suppose that I have base OS support and then a front end that could
work on the OS to provide an interface for the user. The front end could vary
for a system and provide alternative control and featuresets.

## 17:56

The manifest code needs a new exception.

## 18:05

The package code should be placed in another location for the most part. Then
thinking about it, I can adjust the build system (`Build.java`) so that it
uses the package code rather than duplicating it and such.

## 20:27

Thinking about it, I suppose operating system support should be a part of the
JIT. However generally not. The JIT will need to translate special method
calls into some other form. Calling the special magical methods could just be
transformed to a call to another class. However the ABI for the OS must be
matched, otherwise using native debuggers would be much more difficult.

