# 2016/06/14

## 08:34

I would suppose that processes should have their own unique structure manager
which is derived from the top level structure manager provided by the kernel or
interpreter. This way it is easier to tell which objects belong to a given
process along with having each process have their own set of objects which can
completley cleared when a process exits. The kernel itself can just use the
host object manager for the most part.

## 08:39

However when it comes to objects and the kernel itself, there can be a kind of
circularity so to speak. The field positions within objects are needed by the
dynamic compiler and the static compiler to know where fields and methods
are in relation to an object or class.

## 08:47

However, where I am going right now has to be adjusted. Currently all the
classes for a process would be reloaded along with their information. I need to
have it where a class could be derived from the kernel itself. So I suppose
what I need is a `RuntimeClassPath` which is very similar to `ClassPath`
except that classes provided by the kernel are shared among all processes. So
when a new class is requested it is not duplicated. Another thing to consider
are class units. Static class data does not really change much at all, just in
the dynamic linking information. I will need another similar thing to the
`ClassPath` except one that manages singular class units. So in the event that
a `ClassUnit` is shared amongst multiple processes, the information such as its
field alignments will already be known. The one thing that is not known however
would be the class base offset (for super classes).

## 08:54

So to think of it, perhaps when it comes to the kernel, the kernel should not
have a `RuntimeObjectManager` at all. The kernel can be completely oblivious
for the most part about how objects are laid out in memory. It just needs a
way to call the garbage requester when requested.

## 08:58

However, when it comes to the current layout the interpreter and the kernel
which uses the interpreter are completely separated. However the object
spaces are pretty much the same. So perhaps instead the `RuntimeObjectManager`
is given `ClassPath`. I remembers the class unit which contained a class. There
could then be a hierarchical layout to it. The kernel gets the root `ROM` and
then the processes get their own `ROM` as I stated before. However, to reduce
the duplication of `ClassUnit`s in `ClassPath` they need to be shared.
Otherwise there can be pointless duplication of `ClassUnit`s.

## 09:05

`ClassPath`s however can be combined from `ClassUnit`s in a way where two
class paths could have a similarly named `ClassUnit` from a different provider.
The only way to tell them apart is if they are a different object (they are not
`==` to each other). So I suppose in this case I have a `ClassPathProvider`
which instead of using `ClassPath` to create sets of classes, the provider is
given the units and it returns the `ClassPath` instead. Then individual
`ClassUnit`s and the classes contained in them can have implementation
dependent objects associated with them. So then this way, there should never
be a new of a `ClassPath` outside of `ClassPathProvider`. I could even make
`ClassPath` private so to speak and have it only be generated by the provider.
Then with a generic flag this can be used for object association. The
`ClassPath` would have wrapped class unit references. When a class is requested
each unit is checked for given class information. If object layout information
is requested (this would be the _unknown_ special object) then the `ClassPath`
can determine which wrapped `ClassUnit` contains the given class and then
use the information in the given `ClassUnit`. After verification, the
`ClassPathProvider` can call a callback method which can initialize the
internal object reference. This way to the outside it cannot be set and appears
to be an immutable reference. The internal object initializer would already
have the memory accessor associated (for alignment and such) and it would then
calculate the alignment where all the fields should be. Then I would suppose
in the `ClassPath` there is another object association which knows about the
global `CIClass` specific information along with `ClassPath` specific
information. The information that is stored in the `ClassPath` instance could
be instead the base class alignment from the object base and the size of the
class. This way the internal field alignments only need to be calculated once
despite them being shared across multiple `ClassPath`s.


