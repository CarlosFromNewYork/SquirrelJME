# 2016/06/14

## 08:34

I would suppose that processes should have their own unique structure manager
which is derived from the top level structure manager provided by the kernel or
interpreter. This way it is easier to tell which objects belong to a given
process along with having each process have their own set of objects which can
completley cleared when a process exits. The kernel itself can just use the
host object manager for the most part.

## 08:39

However when it comes to objects and the kernel itself, there can be a kind of
circularity so to speak. The field positions within objects are needed by the
dynamic compiler and the static compiler to know where fields and methods
are in relation to an object or class.

## 08:47

However, where I am going right now has to be adjusted. Currently all the
classes for a process would be reloaded along with their information. I need to
have it where a class could be derived from the kernel itself. So I suppose
what I need is a `RuntimeClassPath` which is very similar to `ClassPath`
except that classes provided by the kernel are shared among all processes. So
when a new class is requested it is not duplicated. Another thing to consider
are class units. Static class data does not really change much at all, just in
the dynamic linking information. I will need another similar thing to the
`ClassPath` except one that manages singular class units. So in the event that
a `ClassUnit` is shared amongst multiple processes, the information such as its
field alignments will already be known. The one thing that is not known however
would be the class base offset (for super classes).

## 08:54

So to think of it, perhaps when it comes to the kernel, the kernel should not
have a `RuntimeObjectManager` at all. The kernel can be completely oblivious
for the most part about how objects are laid out in memory. It just needs a
way to call the garbage requester when requested.

## 08:58

However, when it comes to the current layout the interpreter and the kernel
which uses the interpreter are completely separated. However the object
spaces are pretty much the same. So perhaps instead the `RuntimeObjectManager`
is given `ClassPath`. I remembers the class unit which contained a class. There
could then be a hierarchical layout to it. The kernel gets the root `ROM` and
then the processes get their own `ROM` as I stated before. However, to reduce
the duplication of `ClassUnit`s in `ClassPath` they need to be shared.
Otherwise there can be pointless duplication of `ClassUnit`s.

## 09:05

`ClassPath`s however can be combined from `ClassUnit`s in a way where two
class paths could have a similarly named `ClassUnit` from a different provider.
The only way to tell them apart is if they are a different object (they are not
`==` to each other).

