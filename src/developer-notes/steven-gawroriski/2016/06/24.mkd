# 2016/06/24

## 11:39

Based on the URI specification, the scheme specific part is always the path.

## 11:48

Actually a class path system based on URIs could be complex although rather
future proofed. `java.net.URI` has really non-conforming URI layouts and some
of the constructors are very simple and just paste strings together rather
than encoding them as they should.

## 11:57

Actually the JVM could be backed using the standard MEEP interfaces. Instead of
having `class-path`, I just instead have an implementation of the
`SuiteManager` and `TaskManager`. The base would act as a kind of kernel of
sorts.

## 12:00

So there would be basically two levels. A JVM would run as the kernel which
then manages sub-JVMs running at lower ends.

## 12:15

Perhaps the `JVM` can be `final`. Then it can either be constructor or an
implementation specific factory be used. At least with an implementation
specific factory there can be fallbacks in the event new features are added
to the JVM. If something is missing then there would be a fallback.

## 12:32

So the first thing to do for the ability factory is provide an interface that
would be used with the Suite manager to find the launcher JAR. Then once the
JAR is located a task should be created and then switched to.

## 12:38

The JVM's suite manager should have only a single implementation managed by
the JVM itself. However, due to some of the varying needs that might not exist
(such as a filesystem), suites should still be installable by passing the raw
JAR bytes for example (after a download or other unpack).

## 12:46

I will need to implement the classes used in the suite manager since they do
not exist and I have no templates to base from.

## 14:31

I wonder why `SuiteInstaller` and stuff such as `Suite` are classes instead
of interfaces. I suppose the intention that despite there being many managers
that there will just be a set few when it comes to suites? Regardless, the
suite managers and such will instead be an artifact that is used in the
user space process and not the kernel. Otherwise when it comes to suite
management the kernel can get confused if it is running a virtual enviroment
on SquirrelJME or another Java ME implementation.

## 14:48

Especially since `Task` is `final` that means it cannot be used at all. So
SWM is completely client side. However after manually typing out the classes
I have a feel of how it would work.

## 14:58

Unless the `Suite` and `Task` have package private or private constructors that
do not exist in the documentation. JavaDoc really should have included
information if a class can even be constructed at all. I am going to guess that
the constructors are private or package private. The classes that exist are
just stubs which even lack constructors.

## 15:29

And with that the entire MEEP SWM has been implemented. That took about 3 hours
or so to complete.

## 15:29

So what I need to do when it comes to the `JVM` since SWM is application side
(and not JVM side) is just provide access to the available suites via the
`unsafe` classes. So the suite code and such will just call into the system
code and such. However the `JVM` itself can still use some of the MEEP flags
and states such as the enumerations. So there will essentially just be a JVM
side of the MEEP code that `unsafe` bridges to.

