# 2016/06/22

## 08:39

The operations will need a list of externals that it accesses.

## 08:41

What could help is a raw operation map which just has the operation code and
the input values passed to it.

## 08:45

Then I can use interpretations of the raw argument data with a kind of data
interpreter.

## 11:36

I can switch the explicit verification states to use an array where the states
are binary searched instead of using a map.

## 13:56

Perhaps what I can use in the byte code is some kind of pseudo operation
definition of sorts. What really is needed though for the operations is just
the logic that states how it modifies the stack, if it accesses any local
variables, and other things.

## 13:59

So it would basically be a micro operation that defines what a byte code
instruction does. The compiler could actually in a way optimize a program
based on the micro operations rather than the whole operations.

## 14:02

Then stack verification would use the microoperations to determine the input
and output state. An interpreter could also be purely based on the more simpler
micro operations also.

## 17:22

I suppose for micro operations, object would be used instead of integer
values since that would be a bit more expressive.

## 17:25

Alternatively instead of micro operations, there are instead micro-executions.
If a concrete representitive form is needed then that can always be created
from the executions.

## 18:52

One thing to consider however are conditional operations. I suppose I should
have explicit jumps at the end of every operation that points to the
instruction that should be jumped to unconditionally. So after the bulk of
instructions, there will just be an unconditional jump to the next instruction.
This could then be used to build a tree or some other structure used by the
compiler to determine how the program flows for potential optimization. Also
the micro-executions should make native code generation simpler.

## 20:20

Something which I can use are co-dependencies in a way. Have it so I can have
the binary sort code in another package along with the SquirrelJME JVM specific
classes. This way javame-cldc-compact can be kept clear of SquirrelJME specific
classes.

## 20:27

Actually before I do that, I should have a new build system of sorts which
uses code that exists in the project directory as a kind of bootstrap of sorts.
When it comes to the compiler, I can use `-implicit:none` so that classes
which are co-dependencies do not get class files generated in the output. Then
this way I can have source code depend on each other as such yet not require
a special algorithm be used to filter out co-dependencies.

## 20:35

I can also then have a generic build interface that can be given an interface
which can be used with a compiler or run-time system. In the event such a
system would run on SquirrelJME itself the interface will instead map to a Java
compiler which I have written along with an interpreter. Then this way, a build
system can be shared inside and outside of SquirrelJME.

## 20:37

Also, I likely do not need to prefix my packages with `squirreljme` since this
is SquirrelJME.

