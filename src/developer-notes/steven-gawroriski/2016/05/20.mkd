# 2016/05/20

## 08:01

So I suppose for archives, I need a kind of data accessor of sorts. Actually,
if all archives are shared and cached and with my current layout of them
containing classes, resources and other such things might be cachable. I am
going to add a bridge of sorts so that in the future I could potentially cache
any kind of resource for example.

## 08:04

This would then mean that the Executable family of classes would be deprecated
and not used at all. So then this means that the archive finder takes the
sole responsibility of representing native classes and such. `NCIClass` may
just then need a native code returning method.

## 08:22

The `FSArchiveFinder` would be better named as JAR instead. or FSJAR.

## 10:57

Likely it can remain the same. For other forms of binaries such as Palm
databases then alternative means could be used for example.

## 13:56

Actually I need to branch the UI code off along with the standard interface
code. The kernel does not truly need the UI to be a part of it, but only as a
kind of add-on. If on graphical systems the console UI is not used, it would
be a bit of a waste.

## 14:02

I can also make the kernel more modular and have the video console stuff just
be a module that is available to the kernel. Filesystems and other such things
could then just be attached to the module system. An implementation of the
kernel would then implement module interfaces as desired. There could also be
the possibility of non-standard modules also. Modules could also act as a base
for the device IO and other drivers and such. Certain modules such as the
console or filesystem would have a standard interface so that interfaces are
not neededlessly duplicated and such.

## 14:07

Then the archive and executable format could somewhat be removed from the
kernel and be made a module instead. The kernel would also need to have an IPC
system with buffers so that processes may communicate with one another. Then
with the base IPC and module system, the kernel would be kept simpler. The
event system could also just be IPC from a driver to a specific process rather
than a direct event buffer and such. Then the archive stuff and other things
being out of the kernel would result in much simplification. I suppose for
programs which can be executed there would be a `KernelExecutable` instance
or a `KernelProcess` setup which executes a given program.

## 14:15

The datagram communication system I suppose should be similar to something as
if UNIX sockets and UDP were combined into one. Stuff such as network
communications and filesystem read/write could be stored within the socket
buffers for communication between processes. However, if I were to only
permit two processes at a time to communicate with each other, that would
simplicate the IPC process.

## 14:19

I do have to consider that streams and pipes would add overhead and such.
However, I can have a datagram packet which are a bunch of datagrams which
are cached to the kernel and re-used when a process needs it. So instead of
freshly allocating new `byte` arrays, I just have a cached set of free
datagrams. If no free datagrams are large enough to fit the message then a new
one is allocated. When a datagram is finished, `close` is called and the
datagram is placed into a queue so that it may be freed by the garbage
collector in low memory situations. For all datagrams they would have a source
and target process, so when a datagram is sent across processes (or even to
self) it knows the source of the message. One thing that I will need also are
ports similar to TCP/UDP so that datagrams have a specific attachment to some
kind of communication. I can also have multicast and unicast datagrams which
can be sent to multiple processes. When all processes have read the data and
closed the datagram then that data gram is placed into the free queue as
usual. I have to hide the byte arrays for security purposes however, because
otherwise it could be exploited by changing the data. Once a datagram is sent
it is no longer modifiable by a process. I can also have a connect interface
which attaches to another process to send and receive datagrams from. Then
listening sockets could listen for a specific process or from many processes.
So in essence, the kernel/VM would be a microkernel.

