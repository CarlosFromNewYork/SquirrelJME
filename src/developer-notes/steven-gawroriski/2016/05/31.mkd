# 2016/05/31

## 08:08

Thinking about it, package is probably better called module so it does not
conflict with the meaning of Java's package.

## 08:42

Next thing to do is to start the IPC that the launcher will use to control
the kernel. Then following that is starting the actual launcher. Then once
the launcher is started, it will then start the main program if one was
requested.

## 09:52

The process and thread list would likely best be an `ArrayList` so that
when processes or threads are looked up by their ID, they can used a binary
search instead of a linear search.

## 09:57

I must disallow thread and process IDs of zero.

## 10:25

Each process can have its own `KernelIPCAlternative`. This would simplify
the implementation and would also remove the need to have a single lock for
every socket that exists. This way when there are many threads communicating
with each other, they do not have to block each other.

## 10:32

When it comes to the sockets, they can be shared between different
alternatives. So for example when one alternative connects to another, they
both just have a single `KernelIPCSocket` which they share for communication
between each other. One issue however are the socket ID numbers, they would
need to handle having multiple IDs depending if they are the client or the
server. However, technically the socket IDs are only needed with cross
communication. There are also 2 billion socket IDs available. For simplicity
the client and server can share the same socket ID. However, each side needs
its own receive and send buffers anyway. Also sharing IDs could cause
confusion when it comes to the side which is receiving its data. So as a rule,
the sockets cannot have the same handle number used on the client or server.

## 10:43

Then the server itself for server sockets and just use a new `KernelIPCServer`
since servers do not have any send or receive logic at all. Then I need an
interface which will handle the client and server handles.

## 10:52

Actually the connected socket does not even need to know if its a client or
server, it just needs to know if it is primary or secondary socket.

## 14:07

Thinking about it, having primary and secondary IDs for sockets could be a bit
confusing. I could limit the total number of sockets to 32,768 although that
would be a bit bad. It would just be simpler for the client sockets to instead
use a single identifier.

## 14:12

Having the primary and secondary identifiers would also complicate things when
processes are removed as there would be a shared set of handles which can
cause issues if lots of sockets are created.

## 14:23

Also, duplicating the identifier generation code for the third time, so it
becomes a class now.

