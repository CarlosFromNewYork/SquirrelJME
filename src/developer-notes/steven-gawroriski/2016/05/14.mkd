# 2016/05/14

## 08:52

Woke up a bit late this day.

## 10:41

Actually the byte code representation does not know the object a method is
being invoked on, so there cannot be a virtual lookup. This also means there
has to be another special instruction.

## 10:58

If I move some of the verification stuff to the lookup (checking that there
are no circular classes and extending/overridding of finals) then I can remove
that code from the interpreter. Also the compiler would benefit from it also
since it would not have to duplicate all of the access checks and such. I
could also virtually wrap all `NCIClass` and have mapped methods accordingly
as such.

## 13:30

I should keep some kind of statistics, since those would be useful in the
interpreter.

## 13:32

Also, I should be able to implement the `jdb` protocol potentially so I can
actively debug the running virtual machine instance. However, one major issue
with this is how can the interpreter communicate with the debugger when there
is no real communication channel which is possible? I would need to actually
create some socket code perhaps from MIDP 3 and then use that as a kind of
agent using TCP of sorts. Although, there is MEEP. Or GCF.

## 13:47

However the GCF classes do not even specify how lookup of things and such
are even performed. So I would suppose that I am given freedom to implement
the services how I would do it, via the service loader and such. The thing is
however, that I will need an actual launcher that wraps everything up while
performing the needed magic. That would be rather complex at this stage. So I
suppose that the interpreter I am writing cannot have an attached debugger.

## 13:52

I would suppose then, that I would have to define an actual launcher interface.
This would be similar to an application selector. All running threads that
either use real threads or are done via setjmp/longjmp style will be managed
by the launcher. The launcher would need access to the magical stuff. In
essence, the launcher is the kernel and is an important part of the virtual
machine. The launcher should be able to run as a single thread. Any calls in
the class library will just be forwarded to the launcher as a kind of user
space call. So stuff such as permission checking will just cross calls and
such. If I were to design the launcher in a way along with the magical
interfaces where instead of writing the interpreter I have the launcher call
the interpreter from a host virtual machine for now (perhaps Swing and such
for example). There would be a system defined interface which defines and
declares the needed things for the launcher to work. So programs would instead
call into the launcher interface as a kind of system call. Then it should be
handled in a way where the launcher being Java code can work when it is
compiled and when it is running on another JVM such as desktop ones or
SquirrelJME itself. Of course the launcher which runs on the JVM would be stuck
to being interpreted, but tests could be ran on it and such.

## 13:59

Then this would mean there would be a launcher for each individual system
on top of the common base launcher. Having such a launcher would save some time
writing it and having an optionally integrated interpreter in it. For any
system specific stuff not defined in the CLDC I will just need a bridge package
which defines all of the interfaces that my initial host JVM launcher uses.

