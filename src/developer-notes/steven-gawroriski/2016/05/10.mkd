# 2016/05/10

## 10:56

For some simplicity the code parser can handle generation of operation data,
one that provides stack operations and opcode arguments.

## 14:01

Actually for image downscaling with weights, say a region to downscale has a
bunch of colors in it. For example it is mostly white. My previous plan was if
that there were even a single pixel of the border color then it would be
border colored. However this may make things a bit ugly especially when it
comes to borders and such.

## 15:44

For `NCPOp` to work better, I will need to know the potential verification
state of the operation. However, if I ignore this then I can have the states
be a bit implicit so to speak. When I go through the actual decoded operations
I can determine if the stack states are correct and such. By then I would know
the start locations of all basic blocks for example. However the verification
state could still be indicated in the operation, using a similar means of
setting the data like I have done before.

## 15:51

Going to look at the statistics for this repository.

## 19:31

I must learn how to draw my own mascot.

## 19:38

The question is however, do all instructions require basic blocks to be
created for them? The basic blocks only cause stack entries to potentially be
cached. So instructions like `new` need it since that instruction can
initialize classes. Also `new` would likely be implemented as a method call to
an allocator. Instructions such as array store would not need them, but
potentially array loads would. However if an array is stored then it just
consumes temporary stack items. If an exception is thrown before the actual
store (out of bounds or `null`) then nothing is done. The same happens for load
also. However other operations such as put of static and get of static should
be in their own basic blocks since they could initialize classes for example.

## 19:44

Thinking about it, a large number of instructions do not need explicit basic
blocks at all. I can pretty much keep it limited to instructions after method
invocations and such and the targets of jumps.

## 19:45

Exception handlers only care about local variables and the stack items are
all temporary anyway. When a method is called, arguments are popped from the
stack. If I start a basic block on the invocation then all stack items are
saved and then they are saved again before the method call.

