# 2016/05/21

## 07:36

So to write the kernel IPC system so that processes may communicate to each
other.

## 10:19

I do wonder if I should have a lock on the security checks or have them within
locking regions. This way if threads or the kernel are modifying permissions
while one is being checked, it does not get messed up.

## 10:30

The KIOSocket code can use `ReferenceQueue` and `WeakReference` to make it so
the sockets can be cleared away when they are garbage collected and such.

## 10:31

This means that the socket will need a kind of data point. Although
alternatively since everything is garbage collected and managed by the JVM, I
do not have to close a socket. If a process runs out of threads (which is a
known event) then all sockets can automatically be closed and removed. So when
a process detects that no more threads are running (from the main loop) it can
perform a cleanup and close connections of other ends and such before it goes
completely away. Then I can have a flag to indicate that a process is no longer
around and all access to it throws an exception.

## 11:23

When it comes to the UIDisplayManager implementation on the server, I can have
a control scheme set of flags. For example, some interfaces could be running
on game consoles without a keyboard, so they would provide a joystick based
interface. This would then be a hint to the standard display manager that
inputing keyboard keys and such would be impossible. So as an alternative it
can pop up a keyboard (and create a virtual keyboard if there is no native
one) which can generate the required keyboard events.

## 11:40

With the launcher using the IPC via the display manager, this means there
could be an alternative launcher selection possibly.

## 11:51

Actually for sockets, I do not have to use the garbage collector, but I do
have to close the sockets when the process completes.

## 13:59

Having reusable (and thus immutable) datagrams would complicate socket
communication. Reusing packets could get ugly since old state may be able to
creep in.

## 14:02

When clients connect, they should have their connection accepted so that
communication back to them can be performed. It would be similar to TCP in way
except with datagrams. Also if I do not have multicasting and do purely
two ends of a pipe for communication with accepting, that would make things a
bit easier to implement.

## 15:27

For IPO, I should have it as a kind of mailbox kind of system where. Or instead
of `KernelProcess` IPOs, the IPCs can store an object to be shared between the
remote end such as an array which then acts as shared memory across two
processes. This personally would be best for if graphics are done and they
need to be very fast, otherwise sending a frame that was drawn across the
IPC would really slow it down.

## 15:38

Having loops and such with explicit timers is going to very polled which would
result in high CPU usage or a laggy interface. Using monitors I can just have
special event objects which are given to sockets for example. When an event
object is triggered there is either a socket to accept or data to be read.

