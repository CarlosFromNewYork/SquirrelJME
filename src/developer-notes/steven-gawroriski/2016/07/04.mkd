# 2016/07/04

## 11:37

I need to fix the simulator so that instead it is a service based interface
which provides operating system support based on architectures and such
instead of not as concrete sets of data. Get rid of all the providers and just
have a `SimulationProvider` which can create simulations as such.

## 11:44

Today is just rain.

## 12:33

The simulation such as architecture variants can be linked to the JIT for
simplicity.

## 13:16

When it comes to simulating a root filesystem, the basic filesystem layout
could be described in resources associated with JAR resources. This way when
it comes to the binary, no other details have to actually exist. There could
be a special filesystem specifier of sorts which describes the files which
are available on the root. It would not be a simulation of a whole system,
however it should be good enough to allow a basic system to operate
properly. So essentially stuff such as `/bin/sh` for Linux at least would
appear a resource which could use an internal special commands to execute a
command which should be provided by the system (in the event of `system()`
being called). This would also allow specific programs to be ran on the host
without worrying about the host operating system at all. Certain details of
the filesystem, such as block devices and character devices, can be implemented
by classes. The current user directory could be mounted as a certain directory
in the simulated system when applicable. Then this way, I do not have to
worry about forwarding calls to the host system (if in the event the code is
running on Linux). However, this would essentially permit a specific set of
programs to run from any operating system.

## 13:42

Simulation starting details would best be placed into a single object, this
way I can add more potentially in the future without requiring massive
simulator changes.

## 16:32

I likely do not need `EmulatedCPU` at all, it could really just fit within
`SimulationThread` which is initialized and emulates a given CPU such as for
PowerPC.

## 16:56

However, I really need a single emulation core, otherwise I will end up
writing many PowerPC CPU implementations. One thing I could use however is
a generic CPU emulation framework. Not part of the simulator but completely
different. The simualtor itself could use this emulation layer however. I could
also have native emulators available so I can run other operating systems
within them, for example Linux. I could use the emulators in a way where I
could support specific systems in them. I could also just have a much stronger
simulation core also.

## 17:00

However, the emulation sub-system could be used potentially with the actual
run-time running as a kind of co-process potentially. Although, I could just
have a much simpler simulation system which is not complex at all. I could
sacrifice some things such as multiple processes in a way (although I should
not do that, since some processes may rely on it).

## 17:35

A problem is that with the CPU manager, I will need to wrap the TLBs and MMUs
for some CPUs. This depends on the number of TLBs which are available to a CPU,
although ones such as x86 use an address in memory to contain page information.
So I suppose what I can do instead is have a high level emulator that can
emulate hardware. I will write an actual emulator which could run operating
systems and uses BIOSes. When it comes to the simulator, they will just be
based on the emulator except that it would provide some high level wrapping.

## 17:59

Actually being a bit higher than userspace would be handy. So I suppose I
should go for a high level system emulator. This way I can run Linux itself
while I can drop down to lower levels and run Linux programs itself. So I
suppose my initial goal should be running a Linux kernel or perhaps even the
Mac OS X kernel.

## 21:10

With `unsafe` there is a way where I can get away with not having any
binary stubs and assembly bits.

