# 2016/07/19

## 09:43

So I need an efficient means of reading streamed ZIP files. It is possible
though that actual entries are spaced out and potentially not next to each
other as in a normal ZIP file.

## 10:03

I would suppose for stream based reading of ZIPs I will need a way to locate
local file headers. So I need an adjustable buffered input stream where I can
directly access the bytes in the buffer and know their actual positions. Once
a local file header is reached I just then need to switch to a different
size and detect the data descriptor if a uncompressed size was not specified.
So generally something that would be a slight issue would potentially be ZIPs
within ZIPs if they are placed correctly. However, I can calculate the CRC,
size, and uncompressed size. Basically since the descriptor header is optional
I essentially have to check every byte ahead of the current read position to
determine if the compressed, uncompressed size, and CRC match the given file.

## 10:14

Appears the standard ZIP utility included in my system does not support reading
ZIPs from a pipe and working with their data.

## 10:18

Basically for every byte that is read, checks will have to be made to determine
if the end of the single entry has been reached. This would be not be very
efficient since there would be a large number of tests. If the data descriptor
was not option this task would be a bit easier. Probably something that would
be a bit more efficient would be a double queue on the input bytes. So
essentially the dynamic history stream would read from the last set of history
and then there can be a peek method which can read ahead from the source
stream. There can then be a get which returns the current history or at least
a part of that history. This would be the most efficient means of writing the
data. I can use the dynamic buffer code I previously wrote to manage the
buffer and such.

