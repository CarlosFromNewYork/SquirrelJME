# 2016/07/08

## 09:24

So I will need to fix all of the version information and figure out a way to
implement standard liblet descriptions. This would be for standard
functionality dependencies. However I cannot find any property which describes
which standard something implements.

## 09:44

I suppose for other versions and such, I will just use a kind of release
system I suppose. I would say that I will start at `0.0.0`. Once SquirrelJME
is 100% compatible, this will become `1.0.0`. Minor versions in development
will be even numbers such as 0, 2, 4. Although in this case I would ever only
be able to perform 49 releases. So I suppose I will do this at the micro
scale. So initially I will start at `0.0.2` so that it is not zero.

## 11:42

Something that could work is if there is no line based interface possible and
no graphical interface possible, that there could also be a standard I/O
based interface. If it could support non-blocking read/write (so stuff can run
in the background in a cooperative-like manner) or has blocking read/write. In
the event of blocking, I may just have to have a continue command to continue
execution, unless interruption can be detected in which a prompt will appear
and block. So basically...

 * If non-blocking stdin can be read, then input commands can be read without
   blocking running programs.
 * If interrupts are supported then interrupting will go to a prompt.
   * If threads can run in the background, everything would be preemptive.
   * If threads cannot run in the background, continuation would be required
     before execution continues.
 * If stdin blocks and there is no means of interruption then after a certain
   point a prompt will appear waiting for a continue unless something
   requires some kind of input.

## 12:14

So what I need is namespace output.

## 13:44

I would suppose I would need a JIT that is traditional for traditional CPUs.
These would be how CPUs for the past few decades have operated. This would be
nothing non-standard such as esoteric systems or programming languages.

## 17:46

I would suppose that I could also have a traditional namespace writer also for
specific systems too. Generally all of them will follow the same layout at
least (a bunch of machine code, some tables, etc.). Anything esoteric would
completely not fit at all. It would likely be best if the blobs for each and
every architecture were exactly the same.

## 18:28

Having the cache output stream created in the namespace processor does not
make any sense. It should instead be created in the namespace writer if a file
on the disk was requested.

