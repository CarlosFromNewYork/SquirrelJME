# 2016/07/26

## 07:56

Hopefully today I can get to work on the emulator.

## 15:29

For the emulator, I thought about having it where I just load the binary and
just start executing bytes in a specific region (perhaps the end). This would
for the most part be how the real system is handled and such. So then this
way I can have binary initialization be written in Java and be generic as
possible. Compiler magic would handle most of the things.

## 16:35

I really just need components and that is it.

## 16:52

To support recording and replays, components have to be added and initialized
via factories. However the classes could be used. So the system would have an
`addComponent` which takes a `Class`, `String` (id of component), and
`String...`/`Object...` for the component properties.

## 18:49

So component creation can be stored in replays. Currently the class type is
stored, so they cannot be changed at all.

## 19:18

The interpreter runs at 8MHz internally (at least the one created by the
interpreter target builder). 58122500000ps (0.0581225s) was done in about a
minute of just mass printing text.

## 19:22

Currently my emulator is cycle accurate and extremely slow. It takes 13 seconds
for a 8MHz cycle to complete.

	DEBUG -- 1s at 2888363125743347
	DEBUG -- 1s at 2888376866173501 (13740430154 or )
	DEBUG -- 1s at 2888389859357080

This means that is is really slow, too slow for the emulator to truly be
viable for testing. Although cycle accurate is nice, it is far too
undesirable.

## 19:25

So what I really need is a kind of deterministic emulator that does not
run extremely slow. So I suppose what I need instead of running a single
cycle for each method, I need a run to amount to occur instead or similar.

## 19:27

Also, each call essentially is done in a single method, every cycle has its
own method call so there is much overhead. So bulk execution is definitely
needed. There has to be a central loop somewhere which calls all the
associated methods as required and does not cause a method to be called for
each cycle. I suppose what I can do is instead change the emulator code to
not use picotime and instead just have a generic run time amount. Real time
on the system can be virtualized instead. Code to be ran by the CPU could be
read into a buffer and bytes could be interpreted in a giant loop until the
PC leaves the block or a given number of instructions were executed. Then
something I can do is just implement JIT compiling for MIPS instead of the
interpreter. So there would still be an interpreter, but it would just run
MIPS code in my own faux `squirreljme.interpreter` operating system. This would
be a bit more realistic than writing my own instruction format.

