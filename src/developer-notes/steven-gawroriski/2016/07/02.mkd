# 2016/07/02

## 11:53

This weeken is holiday weekend, with Monday being the 4th of July.

## 12:03

I should rework the documentation a bit and have a completely standalone port
section of sorts. Then I can have user and developer bits in their specific
sections.

## 14:28

One thing I need when it comes to the class file decoder is remembering and
storing the class flags for potential usage later. I will need to document
the blob format in a way where it allows blobs to be output without needing
future details. So as such this means that the table of contents in a blob will
be last.

## 14:36

I should have a class which can be given a byte buffer or some other class
which is used to read from say an `int[]` or `byte[]` array to access the
details within a blob.

## 15:36

As alternative to a table of contents kind of thing, I can have a linked list
of sorts through the executable. However, backlinks would not operate at all.
I would say that for simplicity, the blob can be directly memory mapped and
have its structure accessed directly. Also it may be reasonable to have a case
where there are two binaries, one which contains the raw data and another
which contains the table of contents. If the table of contents remains apart
from the executable code they can be linked into the binary using different
means. Alternatively, instead of an `OutputStream` passed into the SSJIT,
there is instead a result of a compilation. So this "smarter" class would have
stuff such as "create new field" and other such things. Then an implementation
of the given writer can be used. Then this way the `SSJIT` is not locked to
a single output format but one which could be wrapped using multiple means.

## 15:46

Then if the output format is not that nice, it can completely be replaced with
a better one without changing any code. So I could literally have an output
which writes ELF binaries.

## 15:51

Essentially what could happen for example when it comes to Linux, is that
classes could be compiled to ELFs, then when they need to be opened they can
be linked in as such. Although, I am not sure if Linux supports dynamic linking
of libraries that exist only in memory. Looking into it, it does not. So when
it comes to generation, I will need to use blobs and such.

## 15:58

When it comes to the output, I should support multiple classes being output
into a single `SSJITOutput`. This way when working with the initial SquirrelJME
binary which the user would use, all classes exist and are pre-merged into it.
The native code would have to be generated in a way where all code acts
together as a single unit. So in this case, entire JARs will be merged into a
single fragment. However, I will need to devise a means where there can be
multiple namespaces within the output (for multi-JAR support).

## 16:01

For example, for the ELF format all symbols and such will be generated and
placed in an output ELF file. Although doing this within an ELF may be complex
because there may be some things which are unknown (such as how large a given
section is).

## 16:06

So I suppose for simplicity, keep with the blobs and instead of a container.
Ther container would be the ELF which loads and initializes the classes
stored within the blob. But still allow for multiple JARs and resources to be
namespaced in a single blob.

## 17:03

Thinking about it, when it comes to generating the bootstrap code, it will be
very difficult to have a split apart JIT when it comes to building the initial
binary which would generate the machine code. Another consideration is the
number of objects that will need to be initialized for every class. So I
suppose I need a separated native code generator, which there is a single
instance for (with functions as I currently have it) where it is then attached
and associated with a state tracker. This way there is a single instance, if
multiple functions need to interact with the same state, they can use the
passed state tracker instead.

## 17:07

So `SSJIT` is given a `NCGManager`. That `NCGManager` will then create any
associated output with a given state and singular set of instances for
functions.

## 17:11

Also going to place anything related to the JIT in
`net.multiphasicapps.squirreljme.jit`, then branch from that for example. The
code generators will be a bit higher level. I would suppose below the
code generator there would be the assembler.

## 17:14

Then this way, when it comes to generating native code I can have similar means
of generating. I will have variants, but instead of operating system
modifications of functions, I instead will have modifications of the code
generator. The assembler, code generator, and JIT should at best be of a single
state which will enable only a single assembler or other instance to exist at
a time. This would reduce the allocation count. I will suppose that for the
assembler, it will be given an output stream. The only consideration is that
there may be the potential for sub-variants of variants (such as big endian
and such).

