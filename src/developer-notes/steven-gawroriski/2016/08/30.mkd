# 2016/08/30

## 06:49

Had a nightmare that a school was throwing out all of their Apple IIes and I
was not allowed to take any of them. So much for preserving some history.

## 07:21

So the thing is, I need a common setup for registers and such for the generic
compiler. But I need a system which is not limited at all. Also, not all
registers could be used at any one time also. One thing to consider is
ABI crossing where SquirrelJME's calling convention does not match that of the
running operating system if native C libraries are to be accessed. However the
main plan is to just have everything be a static binary. Having a dynamic
library such as `libsquirreljme.so` would be interesting however.

## 07:27

Perhaps something that might work better is one something that goes with the
code. Basically the configuration can specify a factory that is to be used to
generate worker helpers for a given target. Essentially instead of specifying
a list of registers and the permitted parts of it, it will basically handle the
register allocation and the stack setup. There just needs to be an initial
setup to determine what is used. Since the generic compiler has for the most
part the same thing for any CPU, it will essentially just be a base class.
It could be part of the configuration but could just be a mapping of helper
factories. So one would register a given class to a specific factory. This way
there can be multiple ones and the configuration system does not have to be
cluttered with unknowns.

## 07:31

Since I have an other note system, I should move the manual stuff away and
place it there.

## 07:54

This should be the most effective, since it would allow multiple class types.
So I just need to make a factory which handles register allocation and such.
Since factory instances vary, I can have their own method. So the generic
compiler stuff for example would need to pass the program being used. Other
kinds of factories would vary depending on the situation. This would be the
most flexible choice and the most adaptive. One thing to consider that a
request for a given class should match the type that was used. So one cannot
register a factory of type `A` and then have it associated with key `B`.

## 07:56

So the generic register allocator will take the purely virtual registers given
by the JIT and manage them. Each instruction address will need to have its
state stored or at least marked for jump targets. This would be so that
jumping back can restore the proper state into the allocated variables and
such. As previously mentioned, the JIT will be a simple stack caching and will
not perform much when it comes to optimizations.

## 08:01

Basically most operations should be easily mapped to native instructions at
least for my first target: MIPS. The most major work when it comes to writing
would essentially be the register allocator, jumping, calling methods, and
exception handling. One a basic layout is done, I would then need to write the
linking system to find classes and such.

## 08:56

So is it a special or is it something else? It would just be a generic class
association mapping for the most part. It would be `registerFoo` and a
`getFoo`, but what are these special things called? I suppose just `Object`
can do.

## 09:02

Then they could also have an extra an optional interface which is used to
potentially configure it via system properties and such. Or it could be
required.

## 14:45

This is quite a bunch of typing adding the skeleton for {@link Display} by
hand.

## 14:55

The LUI interface is not really that great, it definitely is not a traditional
character based terminal with character cells and attributes. It might be a
bit difficult to implement Squirrel Quarrel on this type of display.

## 15:17

And I am done, that took awhile. Although I do have to implement the key event
stuff eventually.

## 16:42

Going to need a way to specify midlets and such.

