# 2016/08/05

## 08:15

So the exception that is hit is this,

	AE0e\ 0\ 1\ false\ true\ true\ true\ 3\ 3\ 3\ 4

Tail (3) minus the true head (3) is zero.

## 11:44

Well it does not occur when the block size is 64, but when it is 4. So it
likely has to do with the block bounds and such. Perhaps related to the true
offset of the data, how it is calculated that is.

## 12:18

Seems when the data is even, the block skipping is not correct.

## 12:20

This seems off `(total - trueaddr)`. Since total is the number of bytes, it has
to be corrected by the head value. So as such it is really
`(total + head) - (__a + head)` or `__a + (total - __a)`.

## 13:09

I should probably use the ticket system more, but I am the only developer so
to speak.

## 13:38

So I just threw out my get first reading now and rewrote it, and it works. I
suppose trying to fix broken code was problematic.


## 13:48

It seems this system I am on now had the basic assets as regular files and
not symlinks, since fossil was not picking them up I just forked. Since get
via last and get via first are pretty much the same, I can just have a booolean
for it.

## 13:54

Now I just need a slightly modified set for going through the list from the
tail end.

## 13:58

Appears I have last working now, except in the case of B. A works however.

## 14:00

It is likely the reason B fails is if the tail is at the edge of a block. So
then now B works and A fails now. Using `-1` works for A, but fails for B.

	for (int i = (tail == 0 ? 0 : -1); i < blskip; i++)
	>

However, it appears they both have a tail of zero and they do.

## 14:00

I would say that then it is this `(head + (total - __a))` that is problematic.

## 17:28

Ok this case fails becuase it wants to read from the first address which in
this case where the total is aligned. The block size is 4, there are 32 bytes
total. So I just did a simple `hasPrevious()` check for now. A, B, and C pass
although D fails with what appears to be an off by one (likely the sliding
window code).


