# 2016/08/29

## 09:33

So I took some ancient code and I adapted it to the future, which saved a bunch
of time. Now what I have to do is delve into the actual parsing of the byte
code and handling it as such.

## 15:02

So the basis of the JIT regardless of platform would be to transform all
stack based work into register based work. The simple caching will be how the
stack caching works (so local to stack will not waste work for the most part).
Additionally I am going to need a new way to specify types used for variable
placement. This would be where for example instead of `__SMTType__` which is
internal, there would be an external one where there is no `TOP` or `NOTHING`
since those should only be artifacts of Java byte code (which I intend to
hide).

## 16:34

So the base JIT will treat the code as if it had 4 billion registers. The
generic JIT on the otherhand will be a bit more limited. However the generic
JIT should be configurable, perhaps based on the variant. Since every system
generally would have support for registers and such, there needs to be a way
to specify which registers and which types are supported. I suppose when it
comes to floating point simulation, that the base JIT can handle that. When a
floating point operation is requested and software mode is to be used then it
will just treat it as `int`/`long` and any operations will just call a generic
static method.

