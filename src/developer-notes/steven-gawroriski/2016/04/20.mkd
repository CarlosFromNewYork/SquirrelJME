# 2016/04/20

## 08:57

So for the single pass compilation, I will also need an existing run-time state
so that final variables may potentially be optimized globally and so that I
actually get global optimizations. I can have the interpreter be similar.
When compiling the memory space will be similar to an actual running system
which essentially sees everything as a bunch of integers. The SSA operations
would essentially be the required operations so that it is easily translated
to the target system.

## 09:16

I suppose for native systems, the SSA will need personalities. For example if
I target a 16-bit CPU it will not have 32-bit add operations so they will need
to be split up if specific values need to be calculated. That is, I will need
to keep a potential value store. If an if is done and a value is say below
100 but greater than zero and a value of 7 is added, I can just keep it as
a 8-bit add instead of requiring a full 32-bits. This would be better for
8-bit and 16-bit systems which I do plan to target. Otherwise even simple math
would take lots of memory and far too many cycles to complete. The personality
will provide details such as the native integer size, if it can do Java
compatible floating point, the memory model (flat, segmented, split data/code,
and banked).

## 09:40

With all of the stack operations and such, and copies I can have a basic high
speed to SSA first which is rather ugly. Then once all of it is loaded in then
optimization can be performed to generate a new program which is faster and
potentially smaller. For the program state, instead of having what I have
before with a set of variables with values I can have instead a global register
file which operations perform work on. So instead of operations having state
such as "variable 2 is an int with value 42." the operations would at on
unique variables given by their IDs (so for example `add $17 = $14 + $12`).
Then in the register file there would be slots for 17, 14, and 12. Another
possible kind of SSA thing would be to only care about side effects. The
register file will contain operations and their derived values from other
registers. Then if a method returns variable 12 then it goes backwards and
performs the required operations to compute the given value. However this would
be easily done if there were no method calls for example. A bunch of methods
could be called which change the state of a global field which to the method
itself it never set in that method, but the one that is called. One major
hurdle is getting the SSA representation to be clean and the ability for
optimization to update variable data and such. At least with a register file
all of the used variables would be in a single location. Each variable could
have direct dependencies. If an operation adds 14 and 12 and puts it into 17
then the variable 17 will have a dependency on that operation.

## 09:50

However, even with copy operations in the SSA code, the native code generation
pass which takes input SSA could determine if any actual work was performed.

## 10:14

However, a very limited system such as ancient 16-bit systems with about only
64K of RAM will be unlikely to load the entire program into SSA form, optimize
it, then generate native code very fast. So, I propose instead a straight
generation pass from Java byte code to machine code with stack caching in a
linear sense. However, in specific cases I cannot cache some items because they
could for example be the start of a for loop. However, if I do not scan the
method before hand for jumps going back I can do a rewind. Since everything is
done in a single pass so to speak, if there is a goto into the back and it goes
for example to the start of a loop then I can just drop everything I performed
and flag a specific state. This would only be handled for a single operation
however. Once its jump back point has been calculated it is dropped and not
done again. However any jump backs will require recalculation. The next thing
to consider is jump forwards (such as `tableswitch` and such). For future
operations I can just set a marker to say that there is a given state. I will
need to store the variable types so that verification is possible and the
stack map can be used. I will do the same thing as before by using a linear
passing of the stack map. However, jump backs which revert state will also
force the stack map to go back also so that it has to be handled again. So if
a jump back occurs, then all known state following the target instruction is
dropped as if it never occured except for that flagging bit. Then for basic
optimization of values instead of having value ranges I can have a sign
extended mask. That is the highest bit of the mask represents the sign bit so
a value of `127` will be `0xFF` along with `-127` using the same even though
`127` is `0x7F`, the extra bit set will represent the sign bit to extend. This
would only work for integers however. Then to remove multiple null checks I
can have a null flagging bit which says that something is known to be null or
not null. For arrays I can have a specifier which gives the array length. For
example, an unknown array would have length `n`. If a request is made to access
index 8 in the array, then a check is made against the size. Following that
access or a similar check against the length of an array will result in the
array having the indices up 8 values be unchecked. The important optimization
would be removing array bounds checks and null pointer checks since those can
be costly. So an operation which performs lots of work on a single array would
eventually get all of its checks removed depending on how the method works.

## 10:30

The next thing would be exceptions. I will do as I thought of before, have the
exceptions be ran first so that the tables are generated at the start. I can
also drop some temporaries because when it comes to exceptions anything that is
on the stack is destroyed. The only thing on the stack is the exception which
is to be handled. So as before, a dedicated register and an index which
specifies the exception table entry which should be handled. With that, there
would only be a need to have a single lookup for exception handling. One
thing however I need to determine when exceptions and gotos exist is block
barriers. Say an exception handler is between a jump forward and another kind
of block and there is no potential jump in. A jump back should not remove the
exception handler code at all. However, it is possible for an exception handler
to jump back into the normal program control flow (an exception handler in a
for loop for example). So exceptions complicate this. So if an exception
performs a goto or similar then it will perform a jump back and the exception
potentially rehandled since it could modify the state of the program. Then
as before, jump forwards would set a future flag that an instruction later is
a jump target. So the most important thing is reading the exception table first
to determine the potential future jumps since past jumps would require
recalculation.

