# 2016/09/18

## 00:04

API wise, it is very small which means it will be easier to implement. I can
have internally driver sets for it. Also due to the age of OpenGL it is more
targetted for older systems. So I could essentially dynamically load OpenGL
libraries potentially and use those for rendering. I would need to have a
driver interface that the standard code set uses. So I would essentially have
a software rasterizer, but for example on the N64 I can have a driver which
uses that GPU.

## 00:08

The `sloccount` of the JD disassembled classes (they are virtually all
interfaces and abstract classes) is only 1,273 lines. So the API itself is
very small indeed. However, I may be getting a bit ahead of myself a bit since
I do not even have a fully working compiler yet.

## 00:12

Since JD's output is rather ugly, I can actually have a doclet which outputs
Java source code. For my previous project (attempted to implement the entire
Java 8 library, about 4000 classes) used something such as this. However that
code is a bit old and rather ugly.


## 00:17

Register saving is just for the most part allocating some stack area and then
copying the value to that. Essentially, I need a pure stack allocation.

## 00:27

So the register allocator will need an allocate method which can allocate to
registers, stack, or both.

## 01:20

`BasicCodeWriter` triggered my code size warning despite it only being about
500 lines long. I suppose I could ignore it however.

## 08:41

JSR 239 has fixed point support, which means a software rasterizer could
potentially work a bit faster if no floating point is available. However one
thing to consider is the floating point parts. I would suppose that when it
comes to actual rendering, that it would use either floating point or fixed
point but render that data directly. So drawing a triangle using the fixed
point functions will draw it using fixed point, while floating point would
draw it using floating point. Floating point would be far more accurate, but
when it comes to fixed point drawing it would not have to convert to float
or vice versa. Other drivers however might convert float to fixed or vice
versa.

## 09:40

I rather feel like rewriting the build system to be a bit better. One thing I
need are profiles. Essentially, stuff such as "minimal" and "opengl" which
include packages. These would be included in the build for the target binary
and select which packages are available for usage. I should also simplify the
bootstrap build system and basically just explicitely compile the packages
required to run things. I just need a class loader interface along with a
Java compiler interface also. This way if I write an internal compiler then
I can use that instead. This build system would be fully self contained.

## 11:20

Ok, so the `Package` classes will turn into `Project` instead. This is so it
does not get confused with Java packages. Following that, I am going to
change `ProjectList` to instead map for `ProjectGroup` which contains binary
and/or source `ProjectInfo`. This way, it is possible for source packages to
be compiled internally and initialized when neeeded. The bootstrap system will
definitely need to perform this task. I thought about having `ProjectInfo`
having a `binary()` and `source()` methods but that would be too complex.

