# 2016/09/02

## 07:52

Thinking about it, I only need to setup registers via the allocator for
input arguments and such when they are primed. I also need to consider the
stack. I do wonder though if I need a sub-variant of the OS to choose the
calling convention. Such as instead of generic I have eabi or o32. These would
just be generic targets for the most part. When it comes to a specific
system such as the CI40 or GCW it can use the appropriate ABI as such. So
instead of say `linux.generic`, for MIPS there will be `linux.eabi` for
selecting the EABI calling convention.

## 10:15

Thinking about it, adding support for new systems is currently complex
because there needs to be all these classes and packages declared across
a large range of areas. Adding base PowerPC projects adds another 6 projects.
Essentially with my given goal of literally being write once and run anywhere,
there will quite literally be perhaps 1000 projects. This would be an
unmaintainable mess. Many systems share the same thing, but just have a few
differences such as the ABI that is used and how the target is built. There
are also emulator considerations also. Right now the emulator for one is
split across many packages for each CPU and such.

## 10:23

What I propose then is merging all of the architectures and variants of a
given OS and just put it into a single package. So that `builder-linux` handles
every Linux system and all of its variants. Also the `TargetBuilder` as it
stands is a bit ugly and will not work as much either. That has to be adjusted
a bit for it to work. But merging the emulator into a single set would be a
good choice because it would all be compacted into a single place. Although
not as modular, it can essentially be a multi-system emulator so to speak. The
purpose of the emulator is to just test targets for the most part.

## 10:38

I also am a bit distracted, I should be implementing the emulators first before
I target a given system, so I can work out how it works and such. The emulators
do not need to be very complex. However, since emulation is part of the core of
target system building, I should refactor the target build system. I am
thinking of a just essentially an enter build. Say the user requests a given
triplet, it will go through all services and try building one that works. I
can have a special exception indicating that the given target is not supported
for the given builder. I thought about removing the OS variants, but that would
be needed in cases where the operating system calls differ for the same target
(such as MIPS o32 and n32 for example).

## 11:24

So as it stands right now, `TargetBuilder` is essentially a factory and its
methods are called as if they were static. This needs to change because it is
very ugly and complicates things.

## 11:27

One thing I can do is move the "can it JIT?" to the build instance instead
of having it in `TargetBuilder`, because it may be possible for the same OS
which has a variant which does not support a JIT (perhaps a ROM based Linux
system that will never run JARs).

## 11:34

`BuildConfig` should get `PackageList` so the build instance can pluck any
packages that are needed.

## 12:34

However, I would have to do some adjusting for that, eventually.

## 13:18

My new main looks much nicer.

