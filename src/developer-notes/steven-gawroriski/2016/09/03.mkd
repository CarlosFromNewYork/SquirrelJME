# 2016/09/03

## 07:01

So now the emulator.

## 07:36

So what I need is a filesystem for the most part, or at least a source of
files.

## 07:38

So that would be basing off `NativeFileSystem` at least what the emulator
will use. So I need perhaps emulator specific volumes. Although one thing I
can do to reuse code is have an abstract filesystem that is completely
virtual for the most part. File access and roots can be handled by classes
using it. I can make this code not use anything that has a part of the
emulator so that it can be reused by SquirrelJME outside of it. So this
would be in effect a completely virtual filesystem.

## 07:47

The emulator could have a virtual ZIP file source, probably as another file.
Essentially it would be one that uses the ZIP code.

## 07:59

One thing I must determine though is how I want to setup the VFS.

## 09:00

It may actually be more efficient to calculate the jump targets of the byte
code and then pass that information to the method writer so it only has to
keep a specific amount of state for jump targets.

## 10:04

So register allocation is simple, I just need a simple way to store the states.
One thing though is that locals and stack item sizes are known in methods and
I only need to store state for all of those locals. So I will need to pass the
number of locals and stack items as Java sees it to the JIT.

## 10:07

And writing this, I got deja vu, in fact double deja vu.

