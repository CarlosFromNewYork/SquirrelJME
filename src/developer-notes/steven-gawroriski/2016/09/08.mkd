# 2016/09/08

## 07:39

Thinking about it, does it really matter if my compiler normally treats saved
and unsaved registers as the same for the most part.

## 07:45

One thing though is that a register could possibly exist in both a register
and the stack, in the event of local variables.

## 08:15

The stack is going to need correction due to the way I pass variables. I make
it so that objects are their native pointer size rather than slot size. One
thing I will have to manage though is making sure no space is wasted on the
stack for objects. Essentially if an object is on the stack it should fit
within a slot. Then I suppose for the allocator if it detects that an attempt
is made for example writing a 64-bit object to a 32-bit slot, that it will
adjust accordingly. This would be better than making all slots 32-bit which
would mean that on 64-bit systems the stack would become extra bloated.

## 09:48

I can do the initial local argument rebinding to the stack as required in the
priming, just after priming I have to generate copies as needed if a local is
in a register argument _and_ the stack.

## 09:52

One thing I might want to do is to decouple the native machine
code bits (stuff that is used by the generic JIT to generate machine code).
In the future I may want to write a second JIT, so I will need to do a
refactoring split of the generic JIT. However, although I could do it now, that
would complicate my current design because I only have a partial JIT and I do
not yet know the final code layout.

## 10:02

However, this only needs to be done for exception handlers. If there are none
in the code then it does not have to be performed.

## 10:04

In fact, if there are no exception handlers then I never need to copy the
locals to the CPU stack at all.

