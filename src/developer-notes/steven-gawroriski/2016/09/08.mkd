# 2016/09/08

## 07:39

Thinking about it, does it really matter if my compiler normally treats saved
and unsaved registers as the same for the most part.

## 07:45

One thing though is that a register could possibly exist in both a register
and the stack, in the event of local variables.

## 08:15

The stack is going to need correction due to the way I pass variables. I make
it so that objects are their native pointer size rather than slot size. One
thing I will have to manage though is making sure no space is wasted on the
stack for objects. Essentially if an object is on the stack it should fit
within a slot. Then I suppose for the allocator if it detects that an attempt
is made for example writing a 64-bit object to a 32-bit slot, that it will
adjust accordingly. This would be better than making all slots 32-bit which
would mean that on 64-bit systems the stack would become extra bloated.

## 09:48

I can do the initial local argument rebinding to the stack as required in the
priming, just after priming I have to generate copies as needed if a local is
in a register argument _and_ the stack.

## 09:52

One thing I might want to do is to decouple the native machine
code bits (stuff that is used by the generic JIT to generate machine code).
In the future I may want to write a second JIT, so I will need to do a
refactoring split of the generic JIT. However, although I could do it now, that
would complicate my current design because I only have a partial JIT and I do
not yet know the final code layout.

## 10:02

However, this only needs to be done for exception handlers. If there are none
in the code then it does not have to be performed.

## 10:04

In fact, if there are no exception handlers then I never need to copy the
locals to the CPU stack at all.

## 10:06

When it comes to `synchronized` methods, if a method is synchronized I will
need a monitor exit before every return and a monitor enter. Additionally,
there will need to be an implicit finally that just does monitor exit. Although
actually, `this` is stored in a local variable somewhere, although it just
needs to be copied somewhere if a method is synchronized so that even if the
`this` variable gets replaced it is not lost. The implicit finally or other
monitor exit can really just load from this special stack location.

## 10:38

Actually with the linkage stuff in the pool, I only need to handle the
calling convention in the generator. Really the linker just takes care of the
links for the most part. This actually simplifies things greatly.

## 10:41

Actually one thing I will need to do is make the global pool accessible to the
sub-writer implementations in the generic code. Although this might not
actually be required at all. The class `GenericMethodWriter` and such can be
changed so that it uses a configuration object of sorts. This way the
constructor can grow as needed in the future.

